% typ dokumentu
\documentclass[12pt,twoside]{article}

% użycie pakietu , jak include
\usepackage{weiiszablon}

% autor pracy
\author{Krystian Olszowy}

% np. EF-123456, EN-654321, ..., Numer albumu
\studentID{EA-167582}

\title{Tworzenie drzewa składniowego języka ST}
\titleEN{{Creating an ST language syntax tree}}


%%% wybierz rodzaj pracy wpisując jeden z poniższych numerów: ...
% 1 = inżynierska	% BSc
% 2 = magisterska	% MSc
% 3 = doktorska		% PhD
%%% na miejsce zera w linijce poniżej
\newcommand{\rodzajPracyNo}{2}


%%% promotor
\supervisor{dr inż. Jan Sadolewski}
%% przykład: dr hab. inż. Józef Nowak, prof. PRz

%%% promotor ze stopniami naukowymi po angielsku
\supervisorEN{Jan Sadolewski, PhD, Eng.}


%% DO ZROBIENIA %%
\abstract{Praca zawiera zaproponowane rozwiązanie sterowania telewizorem z poziomu smartfona dzięki aplikacji mobilnej i urządzeniu pośredniczącemu, opartemu o mikrokontroler z niezbędnymi modułami. Przedstawiono i omówiono w niej technologie i koncepty, z których korzystano podczas procesu projektowania i tworzenia rozwiązania. Opisane zostały też najważniejsze elementy fizycznej części systemu, oprogramowanie mikrokontrolera, zbudowana aplikacja mobilna oraz ich współpraca w celu sterowania urządzeniem telewizyjnym.}
\abstractEN{The work encompasses a solution for television control through a smartphone application and an intermediary device, based on a microcontroller with necessary modules. It introduces and discusses the technologies and concepts employed during the design and building process. Additionally, it details the key components of the physical system, microcontroller software, the developed mobile application, and their collaboration for television device control.}

%% DO ZROBIENIA %%
\keywords{ST language, syntax tree, CPDev, ANTLRv4, parser}
\keywordsEN{język ST, drzewo składniowe, CPDev, ANTLRv4, parser}


\begin{document}

% strona tytułowa
\maketitle

\blankpage

% spis treści
\tableofcontents

\clearpage
\blankpage

\section{Wstęp}
\subsection{Zintegrowane środowiska programistyczne (ang. IDE)}
Współczesny inżynier czy programista automatyki nie wyobraża sobie pracy bez dostępu do zintegrowanego środowiska programistycznego (ang. IDE). Środowiska te, będące podstawowym narzędziem w pracy twórców oprogramowania sterowników PLC, przekształciły się z prostych edytorów kodu w zaawansowane platformy wspierające projektowanie, symulację, testowanie i wdrażanie systemów sterowania. Dzięki nim możliwe jest nie tylko wygodne tworzenie logiki sterującej, ale również wizualizacja procesów, zarządzanie konfiguracją sprzętu czy analizowanie działania programu w~czasie rzeczywistym.

Na rynku dostępnych jest wiele rozwiązań, różniących się zakresem funkcji, kompatybilnością z określonymi typami sterowników oraz poziomem zaawansowania użytkownika. Jednym z przykładów takiego środowiska jest CPDev - polskie oprogramowanie tworzone na Politechnice Rzeszowskiej wspierające języki programowania zgodne z normą IEC 61131-3, które umożliwia programowanie sterowników różnych producentów, symulację działania programu oraz jego późniejsze wdrożenie na urządzeniu docelowym. Choć wiele firm korzysta z komercyjnych środowisk oferowanych przez producentów sterowników, takich jak TIA Portal firmy Siemens czy GX Works rozwijane przez Mitsubishi Electronic, to rosnąca popularność rozwiązań niezależnych - jak CPDev - pokazuje, że możliwe jest tworzenie otwartych, elastycznych i konkurencyjnych narzędzi dla branży automatyki.

\subsection{Drzewa składniowe}
Drzewa składniowe to struktury, które trudno przecenić w świecie programowania. Choć na pierwszy rzut oka mogą wydawać się technicznym detalem, w~praktyce są fundamentem działania wielu elementów środowisk programistycznych. To właśnie one przedstawiają kod w uporządkowanej postaci, zgodnej z gramatyką danego języka, dzięki czemu program może być łatwiej analizowany i przetwarzany.

Bez drzew składniowych trudno wyobrazić sobie działanie kompilatorów, interpreterów, a nawet tak podstawowych funkcji edytora jak kolorowanie składni, podpowiadanie składniowe czy automatyczne formatowanie kodu. Dzisiejsze IDE bazują na tych strukturach niemal na każdym kroku - to one pozwalają na bieżąco wykrywać błędy kodu, usprawniają nawigację w projekcie i umożliwiają wprowadzenie inteligentnych podpowiedzi.

Automatyczne generowanie parserów, znacząco przyspiesza proces interpretacji kodu. Dzięki niemu programista nie musi już ręcznie tworzyć złożonych analizatorów składni, co oszczędza czas i~ogranicza liczbę błędów.

Dla środowiska CPDev możliwość generowania drzewa składniowego dla języka ST to istotne ułatwienie. Dzięki temu można nie tylko szybciej i prościej zaimplementować parser zgodny z normą IEC 61131-3, ale też stworzyć solidną podstawę do rozwijania edytora o nowe funkcje - jak choćby inteligentne podpowiedzi, analiza semantyczna czy lepsza diagnostyka błędów. To wszystko przekłada się na wygodniejszą pracę użytkownika i otwiera drogę do dalszego rozwoju CPDeva jako nowoczesnego narzędzia do programowania sterowników.

\subsection{Cel pracy}
Celem pracy jest przygotowanie parsera kodu języka ST zgodnego z normą IEC 61131-3 oraz oprogramowaniem CPDev, generującego drzewo składniowe na~podstawie podanego kodu źródłowego tego języka. Oprogramowanie generujące drzewo składniowe ma współpracować z kodem w języku C\#. Aby takie oprogramowanie przygotować, należy wcześniej także przeprowadzić badanie porównawcze wybranych narzędzi do tworzenia drzew składni języków formalnych opisanych za pomocą gramatyki bezkontekstowej i wybrać rozwiązanie najbardziej odpowiadające postawionemu zadaniu.

\subsection{Zakres pracy}
Zakres pracy obejmuje prównanie wybranych narzędzi do tworzenia drzew skła\-dni języków formalnych opisanych za pomocą gramatyki bezkontekstowej i wybranie najlepszego z nich do analizowania języka ST zgodnego z normą IEC 61131-3 w~CPDevie. Praca podejmuje także tematykę utworzenia pliku gramatyki języka ST dla najbardziej odpowiedniego z analizowanych narzędzi i przetestowania wygenerowanego oprogramowania dla przykładowych kodów źródłowych.


\subsection{Zawartość pracy [DO ZROBIENIA]}
W rozdziale drugim  omówiono ogólnodostępne rozwiązania stanowiące aktualny stan wiedzy w zakresie zdalnego sterowania odbiornikiem telewizyjnym. Prównano je z autorskim systemem wskazując jego zalety i rozwiązywane przez niego problemy.

Rozdział trzeci zawiera przedstawienie i opis technologii wykorzystanych w zaprojektowanym rozwiązaniu. Są to: Platforma ESP32, język programowania C++, framework Arduino, podczerwień, system Android, język programowania Dart, framework Flutter oraz techonlogia Bluetooth Low Energy.

Czwarty rozdział opisuje sposób połączenia komponentów składających się na urządzenie pośredniczące zbudowane aby skomunikować aplikację mobilną z telewizorem. Zawarte zostały w nim także opisane scharakteryzowane parametry tych komponentów.

W rozdziale piątym szczegółowo omówiono utworzone oprogramowanie mikrokontrolera odpowiedzialne za sterowanie jego zasobami i dołączonymi modułami fizyczymi. Przedstawione zostały ważniejsze kody źródłowe projektu oraz ich działanie.

Rozdział szósty zawiera opis zaprojektowanego intefejsu użytkownika aplikacji mobilnej oraz jej funkcjonalności. Ukazane zostały także wykorzystane podczas implementacji, rozwiązania programowe.

Siódmy rozdział koncentruje się na przedstawieniu sposobu korzystania z utworzonego rozwiązania. Dokonywana jest także ocena skuteczności działania poszczególnych funkcji systemu.

W ostatnim rozdziale zawarto podsumowanie całej pracy, możliwe usprawnienia zaprojektowanego rozwiązania. Wskazane zostały też elementy projektu, które autor uważa za wkład własny.


\clearpage
\section{Środowisko CPDev}
\subsection{Charakterystyka narzędzia}
CPDev (Control Program Developer) to otwarte, uniwersalne środowisko inżynierskie przeznaczone do tworzenia i wdrażania oprogramowania sterującego dla systemów automatyki. Powstało jako efekt wieloletnich prac badawczych i rozwojowych prowadzonych na Politechnice Rzeszowskiej. Głównym założeniem projektowym CPDev było stworzenie platformy, która będzie nie tylko zgodna z normą IEC 61131-3, ale również łatwa do przeniesienia na różne platformy sprzętowe i dostępna dla inżynierów oraz studentów jako narzędzie zarówno edukacyjne, jak i przemysłowe\cite{cpdevKia}.

Jednym z głównych atutów CPDev jest modularność oraz szeroki zakres funkcjonalności obejmujący cały proces tworzenia aplikacji sterujących. Środowisko udostępnia zestaw edytorów tekstowych i graficznych, narzędzia do konfiguracji systemu, symulator sterownika oraz narzędzia do projektowania interfejsów HMI. Dzięki temu możliwe jest kompleksowe projektowanie i testowanie systemów sterowania bez konieczności stosowania zewnętrznych narzędzi.

Ważną cechą CPDev jest jego niezależność sprzętowa, osiągnięta dzięki zastosowaniu warstwy pośredniej w postaci wirtualnej maszyny, która interpretuje kod pośredni generowany przez kompilator. Takie podejście umożliwia łatwe wdrażanie systemu na różnych urządzeniach, w tym na mikrokontrolerach, procesorach ARM, a nawet na implementacjach FPGA\cite{cpdevFPGA}. Jednocześnie zapewnia ono jednolity sposób działania aplikacji niezależnie od platformy sprzętowej.

Środowisko CPDev jest stale rozwijane i udoskonalane. W kolejnych wersjach wprowadzano m.in. wsparcie dla języków graficznych, rozszerzenia dla systemów wielordzeniowych, interfejsy XML pozwalające na współpracę z innymi narzędziami inżynierskimi oraz rozwiązania umożliwiające projektowanie zgodnie z podejściem MDD (Model-Driven Development). CPDev znalazł już zastosowanie w wielu wdrożeniach przemysłowych — zarówno w kraju, jak i za granicą.

Z punktu widzenia użytkownika, środowisko CPDev oferuje funkcjonalności znane z komercyjnych rozwiązań, przy czym wyróżnia się większą otwartością, możliwością adaptacji do konkretnych potrzeb oraz dostępnością szczegółów implementacyjnych. To wszystko sprawia, że CPDev stanowi atrakcyjną alternatywę wobec zamkniętych środowisk oferowanych przez producentów sprzętu automatyki.
\subsection{Programowanie za pomocą CPDev-a}
\subsubsection{Ogólny sposób korzystania z narzędzia}
Programowanie w środowisku CPDev odbywa się w ramach graficznego interfejsu IDE, które integruje różne etapy projektowania systemu automatyki: od pisania kodu sterującego, przez konfigurację sprzętu i symulację, aż po wdrożenie na urządzenie docelowe \cite{cpdev2009}. Proces ten można podzielić na kilka etapów:

\begin{enumerate}[label=\arabic*), leftmargin=1.25cm]
    \item Tworzenie projektu - użytkownik definiuje strukturę programu, dodaje nowe jednostki organizacyjne (POUs), deklaruje zmienne globalne i lokalne.
    \item Kodowanie logiki sterowania -- za pomocą jednego lub kilku języków normy IEC 61131-3.
    \item Konfigurację sprzętu i zmiennych wejścia-wyjścia -- z użyciem narzędzia CPCon.
    \item Symulację i testowanie -- możliwą dzięki narzędziu CPSim, które pozwala uruchomić aplikację sterującą w trybie offline.
    \item Generowanie kodu pośredniego (VMASM) -- po kompilacji, aplikacja może zostać załadowana do wirtualnej maszyny uruchamianej na docelowym sterowniku.
\end{enumerate}

\subsubsection{Dostępne języki programowania sterowników}
CPDev wspiera wszystkie języki określone w normie IEC 61131-3\cite{iec61131-3}, co pozwala użytkownikom wybrać najbardziej pasujący im sposób definiowania logiki sterującej w zależności od specyfiki projektu lub preferencji osobistych. Szczegółowo, obsługiwane przez CPDev języki programowania  to\cite{cpdevLanguages}:

\begin{enumerate}[label=\alph*), leftmargin=1.25cm]
    \item ST (Structured Text)\\
    Język ST jest tekstowym językiem wysokiego poziomu, przypominającym składnią Pascala lub języki z rodziny C. Oferuje bogaty zestaw struktur sterujących (pętle, warunki, bloki), obsługę typów prostych i złożonych oraz wyrażeń logicznych i arytmetycznych. CPDev umożliwia pisanie całych aplikacji w ST, a także używanie go do definiowania funkcji i bloków funkcyjnych. Edytor kodu ST w CPDev jest wyposażone w podświetlanie składni, autouzupełnianie i sprawdzanie błędów składniowych na bieżąco, co znacznie ułatwia pracę programisty. Okno edycji z przykładowym kodem ST przedstawiono na rysunku \ref{Fig:startStopST}.

   \begin{figure}[ht]
   \centering
   \includegraphics[width=12cm]{images/startStopST.png}
   \caption{Wygląd okna edycji prostego kodu ST w programie CPDev}
   \label{Fig:startStopST}
   \end{figure}

    \item IL (Instruction List)\\
    IL to język niskopoziomowy, przypominający asembler. Umożliwia precyzyjne określanie instrukcji operujących na rejestrach i zmiennych. Jego stosowanie w CPDev jest obecnie rzadsze, ponieważ został wycofany z najnowszej wersji normy IEC 61131-3, ale nadal pozostaje dostępny dla kompatybilności. Okno edycji IL w CPDev pozwala na pisanie kodu w formie instrukcji, przedstwiono je wraz z przykładowym kodem na rysunku \ref{Fig:startStopIL}. 

   \begin{figure}[ht]
   \centering
   \includegraphics[width=13cm]{images/startStopIL.png}
   \caption{Wygląd okna edycji prostego kodu IL w programie CPDev}
   \label{Fig:startStopIL}
   \end{figure}

    \item FBD (Function Block Diagram)\\
    FBD jest językiem graficznym, który pozwala na tworzenie logiki poprzez łączenie bloków funkcyjnych w sposób przypominający schematy blokowe. Jest chętnie wykorzystywany przez inżynierów o mniejszym doświadczeniu programistycznym, szczególnie w przemyśle. W CPDev edytor FBD umożliwia tworzenie diagramów blokowych, gdzie każdy blok reprezentuje funkcję lub operację, a połączenia między nimi definiują przepływ danych. Bloki mogą być konfigurowane i łączone w sposób graficzny, co ułatwia zrozumienie logiki sterowania. Przykładowe okno edycji FBD z prostym kodem przedstawiono na rysunku \ref{Fig:startStopFBD}.

   \begin{figure}[ht]
   \centering
   \includegraphics[width=14cm]{images/startStopFBD.png}
   \caption{Wygląd okna edycji prostego kodu FBD w programie CPDev}
   \label{Fig:startStopFBD}
   \end{figure}

    \item LD (Ladder Diagram)\\
    LD, znany także jako język drabinkowy, to język graficzny inspirowany schematami przekaźnikowymi. Ułatwia migrację klasycznych systemów sterowania przekaźnikowego do programowalnych sterowników PLC. CPDev umożliwia tworzenie programów w LD i konwersję do ST. Edytor LD pozwala na graficzne definiowanie logiki sterującej w formie drabinki, gdzie symbole reprezentują elementy logiczne (przekaźniki, styki, cewki), a połączenia między nimi definiują przepływ sygnałów. Przykładowe okno edycji LD z prostym kodem przedstawiono na rysunku \ref{Fig:startStopLD}.

   \begin{figure}[ht]
   \centering
   \includegraphics[width=12cm]{images/startStopLD.png}
   \caption{Wygląd okna edycji prostego kodu LD w programie CPDev}
   \label{Fig:startStopLD}
   \end{figure}

    \item SFC (Sequential Function Chart)\\
    SFC jest językiem służącym do modelowania logiki sekwencyjnej. Program składa się z kroków, przejść i warunków przejścia. W CPDev sekwencyjna struktura tworzona jest graficznie, a logika kroków i przejść może być zapisana w ST lub FBD. Edytor SFC w CPDev pozwala na tworzenie diagramów sekwencyjnych, gdzie każdy krok reprezentuje stan systemu, a przejścia między nimi definiują warunki przejścia. Przykładowe okno edycji SFC z prostym kodem przedstawiono na rysunku \ref{Fig:tanksSFC}.

   \begin{figure}[ht]
   \centering
   \includegraphics[width=12cm]{images/tanksSFC.png}
   \caption{Wygląd okna edycji prostego kodu SFC w programie CPDev}
   \label{Fig:tanksSFC}
   \end{figure}
\end{enumerate}

\subsection{Implementacja CPDev-a i architektura maszyny wirtualnej}

Implementacja środowiska CPDev została oparta na założeniu, że system sterowania powinien być niezależny od konkretnej platformy sprzętowej, a zarazem możliwy do wdrożenia w rzeczywistych aplikacjach przemysłowych. Aby to osiągnąć, architektura CPDev została podzielona na dwa główne poziomy: środowisko deweloperskie (IDE) oraz maszynę wirtualną (VM), która wykonuje wygenerowany program sterujący.

Środowisko deweloperskie CPDev zostało zaimplementowane w języku C\# na platformę .NET, przez co aplikacja posiada nowoczesny interfejs graficzny, wygodę użytkowania i łatwość dalszej rozbudowy. Składa się z modularnych komponentów, takich jak edytory kodu źródłowego, narzędzia konfiguracyjne, symulatory, analizatory błędów i generator kodu pośredniego \cite{cpdevOverview}. Zastosowanie C\# i środowiska .NET pozwala na integrację z innymi narzędziami, obsługę graficznych języków programowania oraz wprowadzanie rozwiązań typowych dla nowoczesnych aplikacji okienkowych (GUI).

Kluczowym elementem działania środowiska jest kompilator, który tłumaczy kod źródłowy napisany w językach normy IEC 61131-3 (głównie ST) do VMASM - pośredniego kodu niskiego poziomu wykonywanego przez maszynę wirtualną. Maszyna wirtualna CPDev-a to lekki, niezależny od sprzętu interpreter kodu VMASM, implementowany głównie w języku ANSI C, co zapewnia wysoką przenośność. Dzięki temu może ona działać na wielu różnych platformach sprzętowych, w tym na mikrokontrolerach (np. AVR, ARM), systemach wbudowanych (np. Raspberry Pi, STM32), a także w symulacji na komputerze PC\cite{cpdevVM}.

\begin{figure}[ht]
   \centering
   \includegraphics[width=15cm]{images/cpdevScheme.png}
   \caption{Schemat przetwarzania kodu użytkownika w środowisku CPDev\cite{cpdevOperations}}
   \label{Fig:cpdevScheme}
\end{figure}

\clearpage

\section{Drzewa składniowe na podstawie gramatyk bezkontekstowych}
\subsection{Wprowadzenie do gramatyk bezkontekstowych}
Gramatyka bezkontekstowa (CFG, Context-Free Grammar) to matematyczny model służący do opisu struktury formalnych języków, takich jak języki programowania. Składa się z: skończonego zbioru symboli nieterminalnych (zmiennych), zbioru symboli terminalnych (symboli końcowych, np. słów kluczowych, operatorów), zestawu produkcyjnych reguł, w których każdy symbol nieteminalny może być zastąpiony ciągiem terminali i/lub nieterminali, specjalnego symbolu startowego. Najważniejszą ich cechą jest to, że zachowują swoje znaczenie niezależnie od kontekstu czyli otoczenia w którym znajduje się symbol. Gramatyki bezkontekstowe są wystarczająco wyraźne, by opisać większość języków programowania, ale jednocześnie na tyle proste, by dawać się wydajnie parsować algorytmicznie.\cite{contextFreeGrammar}

\subsection{Wyprowadzenia i formy zdaniowe}
Proces generowania ciągu terminali rozpoczyna się od symbolu startowego i polega na wielokrotnym zastępowaniu nieterminali zgodnie z regułami gramatyki rozwijając kolejno każdy symbol nieterminalny\cite{contextFreeGrammar}. Taki proces to wyprowadzanie, często opisywany za pomocą kroków typu lewostronnego lub prawostronnego. W każdym etapie generowania teminali powstają tzw. formy zdaniowe, czyli częściowo przetworzone ciągi symboli.

\subsection{Drzewa składniowe}
Drzewo składniowe to uporządkowana struktura w postaci drzewa, która wizualnie i strukturalnie odwzorowuje sposób, w jaki ciąg symboli terminalnych (np. kod programu) został wygenerowany przez gramatykę. Korzeń drzewa to symbol startowy, a każdy węzeł wewnętrzny reprezentuje symbol nieterminalny, który został rozwinięty na swoje dzieci (symboli terminalnych lub innych nieterminali). Z kolei liście drzewa odpowiadają symbolom terminalnym, które są końcowymi elementami wygenerowanego ciągu.

Drzewo składniowe powstaje podczas parsowania: każda reguła produkcji zamienia symbol nieterminalny na jego dzieci w drzewie. Korzystając z kolejności liści od lewej lub prawej, odczytujemy oryginalny ciąg słów, czyli kod źródłowy. Poniżej na rysunku \ref{Fig:simpleGrammarTree} przedstawiono przykład drzewa składniowego dla prostego wyrażenia arytmetycznego \textit{7 + 2 * 3} z zastosowaniem zasad znanych z matematyki, gdzie mnożenie ma wyższy priorytet niż dodawanie.

\begin{figure}[ht]
   \centering
   \includegraphics[width=15cm]{images/grammarTreeSimple.png}
   \caption{Drzewo składniowe dla prostego wyrażenia arytemtycznego \textit{7 + 2 * 3}}
   \label{Fig:simpleGrammarTree}
\end{figure}


Drzewa składniowe mogą służyć jako:
\begin{itemize}[label=\textbullet, leftmargin=1.25cm]
   \item reprezentacja struktury kodu źródłowego, na przejrzystym drzewie,
   \item podstawa do analiz semantycznych, takich jak sprawdzanie typów czy wykrywanie błędów,
   \item model do generacji kodu pośredniego lub docelowego wykorzystywany kompilatorach i interpreterach.
\end{itemize}

\subsection{Zastosowanie parserów w IDE}
W zintegrowanych środowiskach programistycznych drzewa składniowe umożliwiają kolorowanie składni, dynamiczne podpowiedzi, sprawdzanie błędów składniowych, a także refaktoryzację kodu. Dla CPDev-a z uwagi na to, że korzysta on z translatora kodu źródłowego, drzewo składniowe kodu języka ST jest niezbędne do poprawnej analizy i interpretacji kodu. Automatyczna generacja drzewa składniowego na podstawie pliku gramatyki pozwoliłaby na ujednolicenie procesu tworzenia parsera, co jest niezwykle istotne dla rozwoju środowiska CPDev. Dzięki temu możliwe byłoby łatwiejsze wprowadzanie zmian w gramatyce języka ST oraz szybsze dostosowywanie parsera do nowych wymagań.
\clearpage

\section{Przegląd narzędzi do tworzenia parserów automatycznie generujących drzewa składniowe}

W kontekście niniejszej pracy parser składniowy posłuży do analizy języka Structured Text (ST), który jest jednym z pięciu języków programowania określonych w normie IEC 61131-3, używanych do programowania sterowników PLC. Parser ten zostanie zastosowany w ramach oprogramowania CPDev. Celem jest wygenerowanie drzewa składniowego programu ST, które może zostać następnie wykorzystane do dalszych analiz semantycznych, optymalizacji lub transformacji kodu źródłowego.

Z uwagi na specyfikę CPDev  pisanego w języku C\# i bazującego na strukturach .NET  istotne jest, aby wybrane narzędzie do generowania parserów było kompatybilne z tą platformą, a także zapewniało czytelność, rozszerzalność i dobrą integrację z pozostałymi komponentami systemu. W dalszej części tego rozdziału przeprowadzona zostanie analiza wybranych narzędzi do towrzenia parserów automatycznie generujących drzewa składniowe pod kątem ich funkcjonalności, wydajności, wsparcia dla języka C\# oraz możliwości integracji z systemem CPDev. Na tej podstawie zostanie dokonany wybór najlepszego rozwiązania.
\subsection{ANTLRv4}

ANTLR (ANother Tool for Language Recognition) to generator parserów opracowany przez Terence'a Parra i jego zespół. Jego najnowsza wersja czyli ANTLR v4 została wydana w sierpniu 2024 roku i jest objęta licencją BSD3. Narzędzie to stanowi kulminację ponad 25 lat badań nad technikami parsowania języków formalnych. ANTLR4 wpiera aż 10 jezyków docelowych w których może zostać utworzony parser i są to: C++, C\#, Dart, Java, JavaScript, PHP, Python3, Swift, TypeScript oraz Go.\cite{antlr4GitHub} ANTLR v4 jest wykorzystywany w projektach akademickich i przemysłowych takich jak m.in. Twitter (zapytania), Hive i Pig w Hadoop, narzędzia Oracle (SQL Developer), Hibernate, NetBeans, Presto czy MySQL Workbench.\cite{antlr4Org}

\subsubsection{Typ gramatyki i parsera}
ANTLRv4 w utworzonym pareserze wykorzystuje algorytm Adaptive LL(*), często skracany jako ALL(*), będący znaczącym ulepszeniem względem klasycznych parserów LL(k) i wcześniejszej wersji ANTLRv3. W przeciwieństwie do statycznego LL(), ALL() dokonuje analizy lookahead dynamicznie podczas działania parsera, co pozwala na obsłużenie bardziej złożonych oraz naturalnych gramatyk bez konieczności ręcznej transformacji reguł.\cite{antlr4GitHub} Eliminuje też konieczność backtrackingu, typową dla wcześniejszych wersji ANTLR w sytuacjach niejednoznacznych\cite{Antlr4Optimisation}. Poniżej na listingu \ref{Lst:antlrv4SimpleGrammar} przedstawiono przykładową prostą gramatykę dla ANTLRv4 gdzie można zauważyć, że nie było wymagane wykonywanie skomplikowanej struktury zagnieżdzonej znanej z parserów typu top-down\cite{antlr4Book}, którym w istocie jest parser generowany przez to narzędzie.

\lstinputlisting[inputencoding=utf8/cp1250, language={bash}, caption={\protect\input{captions/antlrv4SimpleGrammar.txt}\protect\relax}, label={Lst:antlrv4SimpleGrammar}]{codes/antlrv4SimpleGrammar.txt}

ANTLRv4 umożliwia definiowanie reguł z rekurencją lewą np. \kod{expr: expr '+' expr;} co wcześniej było niemożliwe i sprawiało trudności w parserach typu top-down. Reguły te są automatycznie przekształcane przez ANTLR na odpowiedniki bez rekurencji przez wbudowane mechanizmy przepisujące gramatykę, zachowując przy tym prawidłową kolejność operatorów i skojarzenia. Jednak ANTLR obsługuje wyłącznie bezpośrednią rekurencję lewą i nie wspiera rekurencji pośredniej (czyli wzajemnej między różnymi regułami).

\subsubsection{Ogólny proces generowania parsera}
Proces tworzenia parsera za pomocą ANTLR v4 składa się z kilku nieskomplikowanych kroków, które umożliwiają automatyczne wygenerowanie analizatora składniowego na podstawie formalnej gramatyki języka:

\begin{enumerate}[label=\arabic*., leftmargin=1.25cm]
\item 
Zdefiniowanie gramatyki - Pierwszym krokiem jest utworzenie pliku z rozszerzeniem .g4, w którym zapisuje się reguły gramatyki w notacji zbliżonej do EBNF. Gramatyka zawiera definicje tokenów (reguły leksykalne) oraz struktur językowych (reguły parsera).
\item Uruchomienie generatora - Korzystając z narzędzia antlr4 (np. z wiersza poleceń), generuje się zestaw klas parsera i leksera w wybranym języku programowania (np. C\#, Java, Python). Na przykład dla języka C\#: \kod{java -jar antlr-4.X-complete.jar -Dlanguage=CSharp Expr.g4}
\item Integracja z aplikacją - Wygenerowane klasy mogą zostać dołączone do projektu w wybranym środowisku programistycznym. Z parsera można korzystać poprzez utworzenie instancji klasy leksera i parsera, a następnie przekazanie do nich kodu źródłowego jako tekstu.
\item Obsługa wynikowego drzewa składniowego - ANTLR umożliwia automatyczne przetwarzanie wygenerowanego drzewa składniowego przy pomocy wzorców Visitor lub Listener, co pozwala na dalszą analizę, interpretację lub transformację kodu.

\item Obsługa błędów i debugowanie - Parser domyślnie obsługuje wykrywanie i raportowanie błędów składniowych, a użytkownik może nadpisać domyślne zachowanie (np. logowanie, zatrzymanie parsowania lub odzyskiwanie po błędach).
\end{enumerate}

Dzięki oddzieleniu gramatyki od logiki aplikacji i wsparciu wielu języków programowania, ANTLR v4 umożliwia łatwe i szybkie tworzenie parserów z pełnym drzewem składniowym gotowym do dalszego przetwarzania.

\subsubsection{Tworzenie gramatyki}
Gramatyka w ANTLR v4 zapisywana jest w plikach z rozszerzeniem \kod{.g4} i definiowana w notacji zbliżonej do EBNF (Extended Backus-Naur Form). Plik gramatyki zawiera dwie główne sekcje:
\begin{itemize}[label=\textbullet, leftmargin=1.25cm]
   \item Reguły parsera - definiują strukturę języka, czyli jak poszczególne elementy (np. wyrażenia, instrukcje) są zbudowane z tokenów. Nazwy reguł zaczynają się małą literą.
   \item Reguły leksykalne - definiują tokeny, czyli podstawowe elementy składniowe (np. liczby, słowa kluczowe, operatory). Nazwy reguł zaczynają się wielką literą.
\end{itemize}
Aby zobrazować sposób tworzenia gramatyki w ANTLR v4, poniżej na listingu  \ref{Lst:antlrv4BiggerGrammar}  przedstawiono prostą gramatykę dla wyrażeń arytmetycznych i przypisań. Na początku definiowana jest w niej reguła startowa \kod{program}, która określa, że analizowany tekst składa się z wielu instrukcji zakończonych końcem pliku. Następnie wprowadzone są reguły odpowiadające różnym typom instrukcji, takim jak przypisania i instrukcje warunkowe. Dalej znajduje się reguła \kod{expr}, która opisuje strukturę wyrażeń arytmetycznych i odniesień do zmiennych.

W drugiej części gramatyki znajdują się reguły leksykalne. Określają one sposób rozpoznawania słów kluczowych, identyfikatorów i liczb całkowitych. Na końcu dodano reguły pomijające znaki białe oraz komentarze, aby nie były uwzględniane w analizie składniowej.

\lstinputlisting[inputencoding=utf8/cp1250, language={bash}, caption={\protect\input{captions/antlrv4BiggerGrammar.txt}\protect\relax}, label={Lst:antlrv4BiggerGrammar}]{codes/antlrv4BiggerGrammar.txt}

\subsubsection{Analiza drzewa składniowego}
ANTLR v4 automatycznie generuje pełne drzewo składniowe (Concrete Syntax Tree, CST) na podstawie zdefiniowanej gramatyki. Drzewo to reprezentuje dokładną strukturę analizowanego kodu źródłowego i może być wykorzystane do dalszego przetwarzania na różne sposoby.

Jednym z najczęściej stosowanych podejść jest wzorzec \kod{Visitor}, który pozwala na kontrolowane przechodzenie po węzłach drzewa i wykonywanie operacji zależnych od typu konstrukcji składniowej. Wzorzec ten doskonale sprawdza się przy analizie semantycznej, generowaniu kodu lub przekształceniach drzewa. Alternatywnie, ANTLR udostępnia również mechanizm \kod{Listenera}, który umożliwia reagowanie na wejście i wyjście z każdego węzła reguły gramatycznej w kolejności predefiniowanej przez parser. Listener sprawdza się m.in. przy prostym zbieraniu informacji lub pasywnym śledzeniu struktury kodu.

W praktyce często zachodzi potrzeba uproszczenia struktury drzewa składniowego poprzez konwersję CST do własnej reprezentacji AST (Abstract Syntax Tree). ANTLR tego nie generuje automatycznie, ale umożliwia łatwe ręczne budowanie AST podczas odwiedzania węzłów drzewa — np. przez klasy Visitor.

Dodatkowo ANTLR wspiera narzędzia wizualne, takie jak ANTLR Tool czy ANTLRWorks, które pozwalają graficznie przeglądać drzewa składniowe i śledzić przebieg analizy. Ułatwia to zarówno testowanie parsera, jak i debugowanie trudnych przypadków związanych z niejednoznacznością lub błędami składniowymi.

\subsubsection{Obsługa błędów}
ANTLR v4 udostępnia zaawansowane mechanizmy obsługi błędów składniowych, które umożliwiają zarówno wykrywanie, jak i kontrolowane reagowanie na nieprawidłowości w analizowanym kodzie źródłowym. Domyślnie parser korzysta z klasy DefaultErrorStrategy, która implementuje mechanizm tzw. odzyskiwania po błędach (error recovery). Zamiast przerywać analizę po wykryciu pierwszego błędu, parser stara się kontynuować analizę wejścia, ignorując fragmenty niezgodne z gramatyką lub dokonując prostych poprawek (np. pominięcie niespodziewanego tokena lub podstawienie brakującego). Takie podejście pozwala parserowi wykryć i zgłosić wiele błędów w jednym przebiegu, co jest szczególnie przydatne przy analizie większych plików źródłowych.

W sytuacjach, w których wymagane jest bardziej rygorystyczne podejście, można zastosować strategię BailErrorStrategy, która natychmiast przerywa analizę po napotkaniu pierwszego błędu składniowego. Taki sposób działania znajduje zastosowanie w przypadkach, gdzie analiza częściowo niepoprawnego kodu nie ma sensu lub gdy parser ma być elementem wrażliwego systemu przetwarzania danych, gdzie konieczna jest pełna poprawność wejścia.

ANTLR umożliwia również implementację własnych strategii obsługi błędów, poprzez dziedziczenie po klasie ANTLRErrorStrategy lub BaseErrorListener. Dzięki temu możliwe jest dokładne dostosowanie sposobu raportowania błędów do potrzeb projektu - np. wzbogacenie komunikatów diagnostycznych, przekazywanie błędów do logów systemowych, a także kontrola lokalizacji i kontekstu błędów. Pozwala to tworzyć parsery bardziej przyjazne dla użytkownika końcowego, szczególnie w środowiskach takich jak CPDev, gdzie czytelna diagnostyka błędów może znacząco wspierać proces tworzenia i testowania kodu.

ANTLR oferuje także możliwość podłączenia wielu słuchaczy błędów (error listeners), co umożliwia np. jednoczesne logowanie do pliku, wyświetlanie w interfejsie graficznym oraz rejestrowanie metadanych na potrzeby testów. Takie podejście daje dużą elastyczność w integrowaniu parsera z różnymi komponentami systemu.

Obsługa błędów stanowi jeden z mocnych elementów ANTLR v4 - parser może działać zarówno w trybie diagnostycznym, jak i produkcyjnym, w zależności od wybranej konfiguracji. Dzięki temu narzędzie to dobrze sprawdza się w rzeczywistych zastosowaniach, gdzie nie tylko poprawna analiza poprawnego kodu, ale również umiejętność reagowania na błędy użytkownika jest kluczowa.
\subsubsection{Wydajność i rozszerzalność}
ANTLR v4 opiera się na strategii parsowania LL(*), która wykorzystuje pełny kontekst lewego do prawego przetwarzania wejścia z dowolnie długim spojrzeniem w przód. Choć podejście to może być wolniejsze w porównaniu do analizatorów opartych na technikach LR (np. LALR czy GLR), zwłaszcza w przypadku bardzo dużych lub silnie niejednoznacznych gramatyk, to w praktyce zapewnia ono wystarczającą wydajność dla większości zastosowań, zwłaszcza gdy celem jest czytelność, utrzymywalność i rozszerzalność kodu. W przypadku języków takich jak ST, które mają umiarkowaną złożoność składniową, parsery generowane przez ANTLR działają płynnie i stabilnie.

Jednym z kluczowych atutów ANTLR jest jego rozszerzalność. Parsery można łatwo rozbudowywać o własne akcje semantyczne, klasy pomocnicze czy niestandardowe mechanizmy przetwarzania. Możliwe jest np. dynamiczne podstawianie reguł, filtrowanie węzłów drzewa składniowego lub implementacja własnych systemów diagnostycznych i logujących. Taka elastyczność pozwala na ścisłe dopasowanie parsera do specyfiki analizowanego języka lub systemu, w którym jest on wykorzystywany – jak np. w środowisku CPDev.

ANTLR zachęca również do modularnego projektowania analizatorów, co oznacza, że każdy element (lexer, parser, AST visitor) może być rozwijany niezależnie. Drzewo składniowe można łatwo przekształcać w AST, a następnie analizować, przekształcać lub kompilować przy użyciu osobnych modułów – np. translatorów do kodu maszynowego, optymalizatorów lub narzędzi do statycznej analizy semantycznej. Takie podejście umożliwia budowę złożonych kompilatorów i interpreterów opartych na ANTLR, przy jednoczesnym zachowaniu wysokiego poziomu kontroli i elastyczności w rozwoju oprogramowania.

\subsubsection{Dokumentacja, licencja i wsparcie społeczności}
ANTLR v4 jest bardzo dobrze udokumentowanym i aktywnie rozwijanym narzędziem, co czyni go przyjaznym wyborem zarówno dla początkujących, jak i zaawansowanych użytkowników. Podstawowym źródłem wiedzy jest oficjalne repozytorium, które zawiera dokumentację, przykłady oraz zestaw narzędzi i pluginów wspierających różne języki programowania. Dodatkowo, autor narzędzia - Terence Parr - opracował obszerną książkę The Definitive ANTLR 4 Reference, która w przystępny sposób omawia zasady działania parsera, projektowania gramatyk i integracji z kodem użytkownika.

Dużym atutem ANTLR jest aktywnie wspierana społeczność, dziesiątki otwartych repozytoriów z gotowymi gramatykami oraz liczne fora i grupy dyskusyjne, które ułatwiają rozwiązywanie problemów oraz wymianę doświadczeń. Przykłady gramatyk dla wielu języków są dostępne publicznie, co pozwala na szybki start oraz naukę dobrych praktyk.

ANTLR jest również korzystny pod względem prawnym. Narzędzie jest udostępniane na licencji BSD, która jest licencją otwartoźródłową o bardzo liberalnych warunkach. Pozwala ona na swobodne wykorzystanie narzędzia w projektach komercyjnych, jego modyfikację, integrację z zamkniętym oprogramowaniem, a także rozpowszechnianie wygenerowanego kodu bez dodatkowych ograniczeń. Oznacza to pełną zgodność z wymaganiami projektów takich jak CPDev, w których potrzebne są elastyczne i bezpieczne rozwiązania wspierające rozwój oprogramowania przemysłowego.

\subsubsection{Wady i zalety}
ANTLR v4 to nowoczesne i wszechstronne narzędzie do tworzenia parserów, które łączy wysoką czytelność gramatyki z elastycznym i rozszerzalnym modelem działania. Jego głównymi zaletami są: intuicyjna składnia oparta na formacie EBNF, automatyczne generowanie pełnego drzewa składniowego (CST), obsługa wzorców Visitor i Listener, możliwość łatwej integracji z różnymi językami programowania oraz bardzo dobra dokumentacja i wsparcie społeczności. Narzędzie oferuje również bogate mechanizmy raportowania błędów oraz możliwość tworzenia własnych strategii przetwarzania składni.

Wadą ANTLR może być niższa wydajność w porównaniu do narzędzi opartych na analizatorach LR, szczególnie przy bardzo dużych gramatykach lub kodzie o dużej złożoności. Dla użytkowników oczekujących pełnej automatyzacji tworzenia AST może być też ograniczeniem konieczność samodzielnego budowania uproszczonych struktur drzewa. Niemniej jednak, elastyczność tego rozwiązania pozwala na pełną kontrolę nad procesem analizy składniowej, co z punktu widzenia projektów inżynierskich i badawczych stanowi istotną zaletę.

ANTLR v4 stanowi zatem dojrzałe, dobrze udokumentowane i szeroko stosowane narzędzie, które znakomicie sprawdza się w zastosowaniach wymagających czytelności, rozszerzalności i precyzyjnego sterowania procesem parsowania.

\subsection{Irony.Net}
\subsection{Bison}
\subsection{Porównanie}
\clearpage
\section{Utworzenie parsera języka ST przy pomocy ANTLRv4}
\subsection{Przygotowanie środowiska i utworzenie struktury projektu}
\subsection{Gramatyka - lexer}
\subsection{Gramatyka - parser}
\subsection{Ocena przygotowanego oprogamowania}
\clearpage

\section{Zakończenie}

Niniejsza praca miała na celu zaproponowanie rozwiązania sterowania telewizorem z poziomu smartfona dzięki aplikacji mobilnej i urządzeniu pośredniczącym opartemu o mikrokontroler z niezbędnymi modułami. Omówiono w niej technologie i~koncepty, z których korzystano podczas procesu projektowania tego systemu. Opisane zostały też najważniejsze elementy fizycznej części projektu, oprogramowanie mikrokontrolera, zbudowana aplikacja mobilna oraz ich współpraca w cely sterowania telewizorem.

Utworzony prototyp systemu zapewnił możliwość programowania przycisków pilota w aplikacji mobilnej w oparciu o szesnastkowe kody sygnałów podczerwonych. Kody te można uzyskać przeglądając sieć i strony producentów urządzeń multimedialnych oraz dzięki wbudowanemu w urządzenie pośredniczące czytnikowi kodów IR, który po odebraniu takiego kodu przez podczerwień, wyświetla go na ekranie OLED. Przy pomocy serwera BLE zastosowanego na urządzeniu wysyłającym sygnały podczerwone zapewniono także dostęp do systemu dla wielu użytkowników jednocześnie. Utworzona aplikacja mobilna jest prosta w użytkowaniu i intuicyjna nawet dla użytkowników nieobytych z technologią obecną w dzisiejszych smartfonach, a duże i wyraziste elementy pozwalają się dostrzec nawet z większych odległości.

Zaprojektowany prototypowy system aplikacji mobilnej i urządzenia pośredniczącego opartego o mikrokontroler jest już w pełni funkcjonalny i może nawet zostać przekształcony do produktu komercyjnego. Aby zwiększyć jednak atrakcyjność tego rozwiązania na rynku, można wskazać kilka usprawnień jak na przykład:
\begin{itemize}[label=-,labelsep=0.4cm,leftmargin=0.65cm]
   \item zamknięcie urządzenia pośredniczącego w wygodnej prostokątnej obudowie z odpowiednim rozłożeniem modułów,
   \item wprowadznie automatyzacji programowania kodów IR i wczytywania ich z plików JSON, udostępnianych też na stronie internetowej firmy,
   \item dodanie obsługi inteligentnych gestów użytkownika w aplikacji dla konkretnych typów urządzeń,
   \item wprowadzenie kreatora ekranów przycisków pilota w aplikacji dla maksymalnej uniwersalności rozwiązania,
   \item wprowadzenie systemu logowania, aby przechowywać zestawy przycisków na serwerze, dzięki czemu będą one dostępne dla wielu urządzeń tego użytkownika
   
\end{itemize}

Autor za własny wkład pracy uważa: 
\begin{itemize}[label=-,labelsep=0.4cm,leftmargin=0.65cm]
   \item przegląd i dobór technologii do utworzonego rozwiązania,
   \item zaprojektowanie urządzenia pośredniczącego opartego o mikrokontroler wysyłającego i odbierającego sygnały IR,
   \item zaprojektowanie interfejsu użytkownika aplikacji mobilnej,
   \item zaprojektowanie komunikacji aplikacji mobilnej pilota uniwersalnego z mikrokontrolerem w oparciu o~technologię BLE,
   \item utworzenie odpowiedniego oprogramowania sterującego dla mikrokontrolera,
   \item zbudowanie i oprogramowanie aplikacji mobilnej,
   \item opis oprogramowania i przedstawienie elementów utworzonego systemu.
   
\end{itemize}

\clearpage
\addcontentsline{toc}{section}{Literatura}
\bibliography{biblgr}
\bibliographystyle{plain}

\clearpage

\makesummary

\end{document}
